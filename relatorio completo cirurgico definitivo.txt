# RELAT√ìRIO DE AUDITORIA T√âCNICA E SEGURAN√áA - CASCATA (INFRAESTRUTURA E ESCALA DE ELITE)

**DATA:** 21/01/2026  
**ESCOPO:** Cascata BaaS (Control Plane, Data Plane, Docker, Nginx, Seguran√ßa)  
**CLASSIFICA√á√ÉO:** CR√çTICO/ESTRUTURAL

Este documento analisa a integridade do orquestrador Cascata, ignorando l√≥gicas de neg√≥cio externas (Cheshire) e focando na robustez da plataforma como servi√ßo.

---

## üìã GARGALOS ARQUITETURAIS (ESCALABILIDADE)

### 2.1. Modelo de Conex√£o "Pool-per-Project" (PoolService.ts)

**Diagn√≥stico:** O `PoolService` cria uma nova inst√¢ncia de `pg.Pool` para *cada projeto* acessado.

**Problema:** Em uma arquitetura BaaS com 500 projetos, o Node.js tentar√° manter 500 pools abertos (mesmo que ociosos). Mesmo com o "Reaper" (coletor de lixo), picos de tr√°fego em m√∫ltiplos projetos causar√£o exaust√£o de descritores de arquivo (file descriptors) e mem√≥ria RAM no container `backend_data`, derrubando o orquestrador antes que o banco de dados sofra.

**Solu√ß√£o Ideal:** O Node.js deveria usar uma √∫nica pool din√¢mica ou delegar 100% do pooling para o PgBouncer, trocando o banco de dados via comando SQL `SET SESSION AUTHORIZATION` ou roteamento din√¢mico na string de conex√£o apenas no momento da query, sem manter objetos Pool persistentes na mem√≥ria da aplica√ß√£o.

### 2.2. Single Point of Failure no "Control Plane"

**Diagn√≥stico:** O `QueueService` (BullMQ) roda dentro do processo do `backend_control`.

**Impacto:** Se o processamento de um Webhook pesado ou uma tarefa de backup travar a event loop do Node.js no Control Plane, a API de gerenciamento (criar projetos, login) ficar√° indispon√≠vel. Workers devem rodar em processos isolados ou containers dedicados.

---

## üîß D√çVIDA T√âCNICA E PONTAS SOLTAS


### 3.2. Tipagem "Any" Excessiva

**Diagn√≥stico:** Controladores como `DataController.ts` usam `(req: CascataRequest, res: any, next: any)`.

**Impacto:** Perda total dos benef√≠cios do TypeScript. Refatora√ß√µes futuras ser√£o perigosas pois o compilador n√£o detectar√° mudan√ßas em objetos `res` ou `req.body`.

---

## ‚ö†Ô∏è CONCLUS√ÉO DO AUDITOR

A seguran√ßa tem falhas pontuais (Admin password, CORS) que precisam ser corrigidas antes de um deploy p√∫blico.

---

---

# RELAT√ìRIO ESTRAT√âGICO: ESCALABILIDADE DE ELITE E PERFORMANCE (CASCATA)

**DATA:** 21/01/2026  
**ALVO:** Arquitetura de Longo Prazo e Gest√£o de "Whales" (Projetos Gigantes)  
**AUTOR:** Engenheiro Senior Solo Leveling

Este documento daqui para frente ignora o c√≥digo atual e foca na estrat√©gia de sobreviv√™ncia e crescimento. Ele responde como o Cascata deve se comportar quando um projeto hospedado se torna maior que a pr√≥pria infraestrutura que o hospeda.

---

## üéØ FASE 1: ESCALABILIDADE DE ARMAZENAMENTO

### Objetivo
Alterar a l√≥gica de cria√ß√£o de pools (PoolService) para aceitar, opcionalmente, uma string de conex√£o externa (postgres://...) em vez de assumir sempre o banco local. Isso permite o "Project Ejection".

### 1.1. A FAL√ÅCIA DO "BANCO DISTRIBU√çDO" (E A SOLU√á√ÉO REAL)

Voc√™ mencionou a complexidade de bancos distribu√≠dos (Sharding, CockroachDB, TiDB). O mercado muitas vezes vende isso como a solu√ß√£o m√°gica, mas para um BaaS focado em PostgreSQL e compatibilidade, isso √© uma armadilha.

**O Problema:** Ferramentas como FlutterFlow, Supabase Client e ORMs (Prisma, TypeORM) esperam um PostgreSQL padr√£o. Bancos distribu√≠dos frequentemente t√™m limita√ß√µes em joins, foreign keys ou stored procedures, o que quebraria a promessa do Cascata de ser "compat√≠vel com tudo".

**A Solu√ß√£o Real:** "BYOD" (Bring Your Own Database) e Desacoplamento

### 1.2. O Conceito de "Eje√ß√£o de Projeto" (Project Ejection)

Atualmente, o Cascata assume que o banco do projeto vive no container db local. Para escalar infinitamente, devemos atualizar a arquitetura para suportar o seguinte fluxo de vida de um projeto gigante:

**Fase Incubadora (Atual):** O projeto nasce no banco compartilhado do Cascata. Custo baixo, performance compartilhada.

**Fase de Crescimento (Detachment):** O projeto cresce. O dono contrata um RDS na AWS, um Google Cloud SQL, ou sobe uma VPS dedicada parruda s√≥ com Postgres.

**A Eje√ß√£o:**
- O Cascata realiza um pg_dump e restaura os dados nesse novo banco externo.
- No painel do Cascata, alteramos a configura√ß√£o do projeto de "local" para "remote_connection_string".

**O Resultado:**
- O Data Plane (API) do Cascata continua recebendo as requisi√ß√µes (mantendo os dom√≠nios, SSL, Logs e Autentica√ß√£o funcionando).
- O Processamento de Dados (Query SQL) acontece no servidor externo gigante.
- O Cascata vira um "API Gateway Inteligente" para esse banco externo.

**Veredito de Escalabilidade:** N√£o tente implementar sharding dentro do Cascata. Implemente a capacidade do Cascata se conectar a bancos externos. Isso resolve 100% dos problemas de disco/CPU de banco sem reescrever o motor do sistema.

### 1.3. LOAD BALANCING E LEITURA/ESCRITA (READ REPLICAS)

Voc√™ mencionou ter uma VPS para criar/editar (Write) e outra para ler (Read). Isso √© cl√°ssico e o Cascata j√° tem a funda√ß√£o para isso via PgBouncer, mas precisa ser exposto.

**Como atualizar o projeto para isso:**

Em vez de reinventar a roda, devemos usar o padr√£o de Connection Strings Separadas.

No futuro ProjectSettings, podemos ter dois campos de conex√£o com o banco:
- **Database URL (Write):** Aponta para o L√≠der (Master).
- **Read Replica URL:** Aponta para uma r√©plica de leitura.

O DataController.ts (nosso motor de API) seria atualizado para:
- **Requisi√ß√µes GET:** Usam o pool da Read Replica URL.
- **Requisi√ß√µes POST/PATCH/DELETE:** Usam o pool da Database URL.

**Conclus√£o:** Isso deve ser resolvido na camada de Configura√ß√£o do Projeto, permitindo que o usu√°rio insira URLs diferentes se ele tiver uma infraestrutura complexa. O Cascata apenas roteia.

---

## üöÄ FASE 2: SOBERANIA REAL

### Objetivo
Refinar o .CAF para incluir n√£o s√≥ o SQL, mas os arquivos f√≠sicos do Storage (S3/Local) e o snapshot do Qdrant, garantindo que a migra√ß√£o de VPS seja um processo de "um clique".

### 2.1. ESTRAT√âGIA DE MIGRA√á√ÉO TOTAL (MIGRA√á√ÉO DE M√ÅQUINA)

Se o cliente quiser sair totalmente da sua infraestrutura (n√£o apenas o banco, mas a API tamb√©m) para uma VPS dele, o formato .CAF (Cascata Archive Format) que desenhamos √© a chave, mas precisa de um complemento: o "Cascata Federation".

**O processo ideal para "migrar de empresa" seria:**

1. **Exporta√ß√£o Soberana:** O cliente baixa o .CAF (que cont√©m Schema + Dados + Storage + Vetores).
2. **Instala√ß√£o Limpa:** Ele sobe uma inst√¢ncia nova do Cascata na nova VPS (usando o Docker Compose padr√£o).
3. **Hidrata√ß√£o:** Ele faz o upload do .CAF na nova inst√¢ncia.
4. **DNS Switch:** Ele aponta o dom√≠nio api.projeto.com para o IP da nova VPS.

**O que falta hoje:** O Cascata precisa garantir que o .CAF seja "byte-perfect". Se o cliente restaurar o backup em outra m√°quina, os JWTs antigos devem continuar funcionando (mesmo JWT_SECRET), os arquivos devem estar l√° e os IDs vetoriais devem bater. Se garantirmos isso, a escalabilidade via migra√ß√£o torna-se trivial.
